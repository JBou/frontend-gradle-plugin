import{_ as S,u as X,a as H}from"./B3Uso2j1.js";import{_ as P}from"./D5XL0elt.js";import{_ as g,a as N}from"./BOqwjjew.js";import{_ as Z}from"./QmxwIEzA.js";import{_ as K,a as W,b as Q,c as ee,d as ne,e as te,f as ae}from"./DQdY6t8U.js";import{a as oe,_ as se}from"./BtNWQ_Pt.js";import{_ as b}from"./BSZ3xRWO.js";import{_ as w,a as I,b as F}from"./C_hFKjrj.js";import{_ as G}from"./B1Cn1jyM.js";import{g as k,o as f,f as v,w as t,d as e,b as n,a as s,c as le}from"./D71axJVe.js";import{_ as ie}from"./DnGS1Mv3.js";import{_ as J}from"./BifUc8Yf.js";import{_ as A}from"./DBovWzHr.js";import{_ as re}from"./CwGFdNW4.js";import{_ as ce}from"./Deewjiqo.js";import{_ as pe}from"./DCkGD3g2.js";import{_ as de}from"./BEHa1Srm.js";import{_ as ue}from"./DM2uf8uD.js";import{u as me}from"./CUOE0wSc.js";import"./DlAUqK2U.js";import"./BfsWJKyW.js";const _e=k({__name:"install-node-task",setup(y){const r=[{name:"nodeVersion",type:"S",binding:"P",property:"nodeVersion"},{name:"nodeDistributionUrlRoot",type:"S",binding:"P",property:"nodeDistributionUrlRoot"},{name:"nodeDistributionUrlPathPattern",type:"S",binding:"P",property:"nodeDistributionUrlPathPattern"},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"}],p=[{name:"nodeExecutableFile",type:"RF",binding:"C"}];return(h,l)=>{const a=S,o=b,i=g,c=oe,d=w,u=I,_=G,x=F;return f(),v(x,{name:"installNode",inputs:r,outputs:p},{title:t(()=>[e("Install "),n(a)]),nodeExecutableFile:t(()=>[n(o,{name:"nodeInstallDirectory"}),n(i,null,{default:t(()=>[e("/node.exe")]),_:1}),e(" or "),n(o,{name:"nodeInstallDirectory"}),n(i,null,{default:t(()=>[e("/bin/node")]),_:1}),e(" depending on the O/S. ")]),skipConditions:t(()=>[e(" property "),n(o,{name:"nodeDistributionProvided"}),e(" is "),n(i,null,{default:t(()=>[e("true")]),_:1}),e(". ")]),description:t(()=>[s("p",null,[e(" The task downloads a "),n(a),e(" distribution, verifies its integrity, and installs it in the directory pointed by the "),n(o,{name:"nodeInstallDirectory"}),e(" property. The URL used to download the distribution is resolved using the "),n(o,{name:"nodeDistributionUrlRoot"}),e(" property and the "),n(o,{name:"nodeDistributionUrlPathPattern"}),e(" property. Checking the distribution integrity consists of downloading a file providing the distribution shasum. This file is expected to be in the same remote web directory than the distribution archive. For example, if the distribution is located at "),n(i,null,{default:t(()=>[e("https://nodejs.org/dist/vX.Y.Z/node-vX.Y.Z-win-x64.zip")]),_:1}),e(", the plugin attempts to download the shasum file located at "),n(i,null,{default:t(()=>[e("https://nodejs.org/dist/vX.Y.Z/SHASUMS256.txt")]),_:1}),e(". By default, the plugin relies on the VM "),n(c,null,{default:t(()=>[e("network properties")]),_:1}),e(" to know if a proxy server shall be used when downloading the distribution and the shasum. A custom proxy server may also be used by defining "),n(o,{name:"httpsProxyHost"}),e(" property (respectively "),n(o,{name:"httpProxyHost"}),e(" property) if the "),n(o,{name:"nodeDistributionUrlRoot"}),e(" property uses the "),n(i,null,{default:t(()=>[e("https")]),_:1}),e(" protocol (resp. uses the "),n(i,null,{default:t(()=>[e("http")]),_:1}),e(" protocol). In case of connectivity/HTTP error, download of the distribution file and the shasum file may be retried using property "),n(o,{name:"maxDownloadAttempts"}),e(". ")]),s("p",null,[e(" If a "),n(a),e(" distribution is already installed in the system, either as a global installation or as an installation performed by another Gradle (sub-)project, and shall be used instead of a downloaded distribution, take a look at the "),n(o,{name:"nodeDistributionProvided"}),e(" property instead: when "),n(i,null,{default:t(()=>[e("true")]),_:1}),e(", this task is ignored if invoked during a Gradle build, and its outcome will always be "),n(d,{outcome:"SKIPPED"}),e(". ")]),s("p",null,[e(" The task takes advantage of "),n(u,{path:"/performance/#incremental_build"},{default:t(()=>[e("Gradle incremental build")]),_:1}),e(", and is not executed again unless one of its inputs/outputs changed. In this case, the task outcome will be "),n(d,{outcome:"UP-TO-DATE"}),e(". ")]),n(_,null,{default:t(()=>[e(" This task should not be executed directly. Gradle executes it if the build requires it. ")]),_:1})]),_:1})}}}),he=k({__name:"install-corepack-task",setup(y){const r=[{name:"packageJsonDirectory",type:"F",binding:"P",property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"},{name:"corepackVersion",type:"RF",binding:"P",property:"corepackVersion"}],p=[{name:"corepackModuleDirectory",type:"D",binding:"C"}];return(h,l)=>{const a=b,o=g,i=ie,c=S,d=J,u=I,_=w,x=G,D=F;return f(),v(D,{name:"installCorepack","depending-task-names":["installNode"],inputs:r,outputs:p,"custom-environment-variables-supported":""},{title:t(()=>[e("Install/upgrade Corepack")]),corepackModuleDirectory:t(()=>[n(a,{name:"nodeInstallDirectory"}),n(o,null,{default:t(()=>[e("/node_modules/corepack")]),_:1}),e(". ")]),skipConditions:t(()=>[n(a,{name:"corepackVersion"}),e(" property is "),n(o,null,{default:t(()=>[e("null")]),_:1}),e(". ")]),description:t(()=>[s("p",null,[e(" The purpose of this task is to allow replacing the default version of "),n(i),e(" embedded in "),n(c),e(". This may be necessary in case of "),n(i),e(" fails to install the package manager used by the project, or to continuously benefit from the latest improvements and bug fixes. By default, this task is not executed unless property "),n(a,{name:"corepackVersion"}),e(" is defined with a non-"),n(o,null,{default:t(()=>[e("null")]),_:1}),e(" value. In the latter case, the plugin executes command "),n(o,null,{default:t(()=>[e("npm install -g corepack[@<corepackVersion>]")]),_:1}),e(". Apart from a specific version number, if this property is set with the "),n(o,null,{default:t(()=>[e("latest")]),_:1}),e(" value, the plugin installs the latest version available. Note that this task will not be executed again and update Corepack automatically if a newer version is released after this task has run once successfully. Since the project may use a package manager that is not "),n(d),e(", the task disables Corepack strict behavior when running "),n(o,null,{default:t(()=>[e("npm")]),_:1}),e(" (see environment variable "),n(i,{path:"#environment-variables",label:"COREPACK_ENABLE_STRICT"}),e("). ")]),s("p",null,[e(" As the task touches the "),n(c),e(" install directory, please pay attention when using a shared "),n(c),e(" distribution ("),n(a,{name:"nodeDistributionProvided"}),e(" is "),n(o,null,{default:t(()=>[e("true")]),_:1}),e("), because this task will impact other projects using "),n(i),e(". This may be desirable or not depending on your situation. ")]),s("p",null,[e(" The task takes advantage of "),n(u,{path:"/performance/#incremental_build"},{default:t(()=>[e("Gradle incremental build")]),_:1}),e(", and is not executed again unless one of its inputs/outputs changed. In this case, the task outcome will be "),n(_,{outcome:"UP-TO-DATE"}),e(". ")]),n(x,null,{default:t(()=>[e(" This task should not be executed directly. Gradle executes it if the build requires it. ")]),_:1})]),_:1})}}}),ge=k({__name:"resolve-package-manager-task",setup(y){const r=[{name:"packageJsonFile",type:"RF",binding:"C",optionalHint:"Whether this file exists or not changes the behavior of the task, see description hereafter."},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"}],p=[{name:"packageManagerSpecificationFile",type:"RF",binding:"C"},{name:"packageManagerExecutablePathFile",type:"RF",binding:"C"}];return(h,l)=>{const a=b,o=g,i=S,c=I,d=w,u=G,_=F;return f(),v(_,{name:"resolvePackageManager","depending-task-names":["installNode"],inputs:r,outputs:p,cacheable:""},{title:t(()=>[e("Resolve package manager")]),packageJsonFile:t(()=>[n(a,{name:"packageJsonDirectory"}),n(o,null,{default:t(()=>[e("/package.json")]),_:1})]),packageManagerSpecificationFile:t(()=>[n(a,{name:"cacheDirectory"}),n(o,null,{default:t(()=>[e("/resolvePackageManager/package-manager-specification.txt")]),_:1})]),packageManagerExecutablePathFile:t(()=>[n(a,{name:"cacheDirectory"}),n(o,null,{default:t(()=>[e("/resolvePackageManager/package-manager-executable-path.txt")]),_:1})]),description:t(()=>[s("p",null,[e("The behavior of this task depends on the existence of the "),n(o,null,{default:t(()=>[e("package.json")]),_:1}),e(" file:")]),s("ul",null,[s("li",null,[e(" If the "),n(o,null,{default:t(()=>[e("package.json")]),_:1}),e(" file exists, the task identifies the name and the version of the package manager applicable to the project by parsing the "),n(i,{path:"/api/packages.html#packagemanager",label:"packageManager"}),e(" property. For example, if the "),n(o,null,{default:t(()=>[e("package.json")]),_:1}),e(" file contains "),n(o,null,{default:t(()=>[e('"packageManager":Â "npm@9.6.7"')]),_:1}),e(", the task resolves "),n(o,null,{default:t(()=>[e("npm")]),_:1}),e(" as the name of the package manager, and "),n(o,null,{default:t(()=>[e("9.6.7")]),_:1}),e(" as its version. ")]),s("li",null,[e(" If the "),n(o,null,{default:t(()=>[e("package.json")]),_:1}),e(" file does not exist, the task removes output files to prevent side effects with other tasks provided by the plugin. ")])]),s("p",null,[e(" The task takes advantage of "),n(c,{path:"/performance/#incremental_build"},{default:t(()=>[e("Gradle incremental build")]),_:1}),e(", and is not executed again unless one of its inputs/outputs changed. In this case, the task outcome will be "),n(d,{outcome:"UP-TO-DATE"}),e(". ")]),n(u,null,{default:t(()=>[e(" This task should not be executed directly. Gradle executes it if the build requires it. ")]),_:1})]),_:1})}}}),ke=k({__name:"install-package-manager-task",setup(y){const r=[{name:"packageJsonDirectory",type:"F",binding:"P",property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"},{name:"packageManagerSpecificationFile",type:"RF",binding:"C"}],p=[{name:"packageManagerExecutableFile",type:"RF",binding:"C"}];return(h,l)=>{const a=b,o=g,i=A,c=I,d=w,u=G,_=F;return f(),v(_,{name:"installPackageManager","depending-task-names":["installCorepack","resolvePackageManager"],inputs:r,outputs:p,"custom-environment-variables-supported":""},{title:t(()=>[e("Install package manager")]),packageManagerSpecificationFile:t(()=>[n(a,{name:"cacheDirectory"}),n(o,null,{default:t(()=>[e("/resolvePackageManager/package-manager-specification.txt")]),_:1})]),packageManagerExecutableFile:t(()=>[e(" the package manager executable, whose path is provided by file "),n(a,{name:"cacheDirectory"}),n(o,null,{default:t(()=>[e("/resolvePackageManager/package-manager-executable-path.txt")]),_:1}),e(" (generally "),n(a,{name:"nodeInstallDirectory"}),n(o,null,{default:t(()=>[e("/[npm|pnpm|yarn].cmd")]),_:1}),e(" or "),n(a,{name:"nodeInstallDirectory"}),n(o,null,{default:t(()=>[e("/bin/[npm|pnpm|yarn]")]),_:1}),e(" depending on the O/S). ")]),skipConditions:t(()=>[n(a,{name:"packageJsonDirectory"}),n(o,null,{default:t(()=>[e("/package.json")]),_:1}),e(" file does not exist. ")]),description:t(()=>[s("p",null,[e(" The task installs the package manager resolved with task "),n(i,{name:"resolvePackageManager"}),e(", by executing command "),n(o,null,{default:t(()=>[e("corepack enable <package-manager>")]),_:1}),e(". ")]),s("p",null,[e(" The task takes advantage of "),n(c,{path:"/performance/#incremental_build"},{default:t(()=>[e("Gradle incremental build")]),_:1}),e(", and is not executed again unless one of its inputs/outputs changed. Consequently, if the task takes part of a Gradle build, its outcome will be "),n(d,{outcome:"UP-TO-DATE"}),e(". ")]),n(u,null,{default:t(()=>[e(" This task should not be executed directly. Gradle executes it if the build requires it. ")]),_:1})]),_:1})}}}),fe={class:"card my-3"},ye={class:"card-body"},be={class:"card-title"},Fe={class:"card-text"},ve=s("span",{class:"font-italic"},"by default",-1),Te=k({__name:"install-frontend-task",setup(y){const r=[{name:"packageJsonDirectory",type:"F",binding:"P",property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"},{name:"script",type:"S",binding:"P",property:"installScript"}];return(p,h)=>{const l=b,a=g,o=S,i=P,c=w,d=A,u=re,_=J,x=K,D=ce,C=pe,j=N,L=F;return f(),v(L,{name:"installFrontend","depending-task-names":["installPackageManager"],inputs:r,"custom-environment-variables-supported":""},{title:t(()=>[e("Install frontend dependencies")]),skipConditions:t(()=>[n(l,{name:"packageJsonDirectory"}),n(a,null,{default:t(()=>[e("/package.json")]),_:1}),e(" file does not exist. ")]),description:t(()=>[s("p",null,[e(" Depending on the package manager, this task executes either command "),n(a,null,{default:t(()=>[e("npm install")]),_:1}),e(", or command "),n(a,null,{default:t(()=>[e("pnpm install")]),_:1}),e(", or command "),n(a,null,{default:t(()=>[e("yarn install")]),_:1}),e(", by default. Consequently, the command shall install project dependencies according to the algorithm followed by each package manager (see hereafter). Optionally, this command may be customized with the "),n(l,{name:"installScript"}),e(" property (e.g. to run a "),n(a,null,{default:t(()=>[e("npm ci")]),_:1}),e(" command instead). On a developer workstation, executing this task is a good starting point to setup a workspace for development as it will install the "),n(o),e(" distribution (if not provided) as well as dependencies. ")]),s("div",fe,[s("div",ye,[s("h5",be,[e(" About "),n(i,{path:"/current/userguide/incremental_build.html"},{default:t(()=>[e("incremental build")]),_:1}),e(" and up-to-date checks ")]),s("div",Fe,[s("p",null,[e(" If you execute this task several times in a row, you may notice the "),n(a,null,{default:t(()=>[e("npm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("pnpm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("yarn")]),_:1}),e(" command is always executed: Gradle does not reuse task outputs based on a previous execution with the "),n(c,{outcome:"SUCCESS"}),e(" outcome. This is the expected behaviour "),ve,e(" because the task does not declare any relevant input(s) and output(s) Gradle could track to know the task is already "),n(c,{outcome:"UP-TO-DATE"}),e(" (e.g. unlike the "),n(d,{name:"installNode"}),e(" task). Resolving these inputs/outputs is a bit complex, since it depends on the package manager, the value of the "),n(l,{name:"installScript"}),e(" property, and the files present in the project. That's why incremental build for this task is not available out-of-the-box by now. However, some "),n(u,{path:"/tree/main/examples"},{default:t(()=>[e("examples")]),_:1}),e(" provide guidelines to customize this task and limit executions under certain circumstances. Notes hereafter provide also some unofficial ideas: ")]),s("ul",null,[s("li",null,[n(_),e(": inputs may be one or more of files "),n(a,null,{default:t(()=>[e("package.json")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("npm-shrinkwrap.json")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("package-lock.json")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("yarn.lock")]),_:1}),e(", while outputs may be the "),n(a,null,{default:t(()=>[e("node_modules")]),_:1}),e(" directory and the "),n(a,null,{default:t(()=>[e("package-lock.json")]),_:1}),e(" file (see "),n(x,{path:"/cli/v10/commands/npm-install"},{default:t(()=>[e("npm install")]),_:1}),e("). If the "),n(l,{name:"installScript"}),e(" property is set with "),n(a,null,{default:t(()=>[e("ci")]),_:1}),e(", file "),n(a,null,{default:t(()=>[e("package-lock.json")]),_:1}),e(" or file "),n(a,null,{default:t(()=>[e("npm-shrinkwrap.json")]),_:1}),e(" may be the only possible input file, if one or the other exists, and the "),n(a,null,{default:t(()=>[e("node_modules")]),_:1}),e(" directory the only output. ")]),s("li",null,[n(D),e(": inputs may be one or more of files "),n(a,null,{default:t(()=>[e("package.json")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("pnpm-lock.yaml")]),_:1}),e(", while outputs may be the "),n(a,null,{default:t(()=>[e("node_modules")]),_:1}),e(" directory and the "),n(a,null,{default:t(()=>[e("pnpm-lock.yaml")]),_:1}),e(" file. ")]),s("li",null,[n(C),e(": inputs may be one or more of files "),n(a,null,{default:t(()=>[e("package.json")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("yarn.lock")]),_:1}),e(", while outputs may be the "),n(a,null,{default:t(()=>[e("node_modules")]),_:1}),e(" directory, or the "),n(a,null,{default:t(()=>[e(".pnp.cjs")]),_:1}),e(" file and the "),n(a,null,{default:t(()=>[e(".yarn/cache")]),_:1}),e(" directory ("),n(C,{label:"Zero-installs",title:"Zero-Install feature"}),e("), and the "),n(a,null,{default:t(()=>[e("yarn.lock")]),_:1}),e(" file. ")])]),s("p",null,[e(" If you are about to tweak this task to declare additional inputs and outputs, take a look at these "),n(j,{path:`${p.$config.public.paths.tasks}#builtin-tasks-customization`},{default:t(()=>[e("recommendations")]),_:1},8,["path"]),e(". ")])])])])]),_:1})}}}),xe=k({__name:"clean-frontend-task",setup(y){const r=[{name:"packageJsonDirectory",type:"F",binding:"P",property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"},{name:"script",type:"S",binding:"P",property:"cleanScript"}];return(p,h)=>{const l=b,a=g,o=P,i=F;return f(),v(i,{name:"cleanFrontend","depending-task-names":["installFrontend"],inputs:r,"custom-environment-variables-supported":""},{title:t(()=>[e("Clean frontend artifacts")]),skipConditions:t(()=>[n(l,{name:"packageJsonDirectory"}),n(a,null,{default:t(()=>[e("/package.json")]),_:1}),e(" file does not exist, or "),n(l,{name:"cleanScript"}),e(" is "),n(a,null,{default:t(()=>[e("null")]),_:1}),e(". ")]),description:t(()=>[s("p",null,[e(" This task does nothing by default, considering frontend artifacts (minimified Javascript, CSS, HTML files...) are generated in the "),n(a,null,{default:t(()=>[e("${project.buildDir}")]),_:1}),e(" directory. If it is not the case, this task may be useful to clean the relevant directory. A clean script shall be defined in the "),n(a,null,{default:t(()=>[e("package.json")]),_:1}),e(" file, and the "),n(l,{name:"cleanScript"}),e(" property shall be set with the corresponding "),n(a,null,{default:t(()=>[e("npm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("pnpm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("yarn")]),_:1}),e(" command. Apart from direct execution, the task is also executed when the Gradle lifecycle "),n(o,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:t(()=>[e("clean")]),_:1}),e(" task is executed. ")])]),_:1})}}}),we={class:"card my-3"},De={class:"card-body"},Pe={class:"card-title"},Ce={class:"card-text"},Se=k({__name:"assemble-frontend-task",setup(y){const r=[{name:"packageJsonDirectory",type:"F",binding:"P",property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"},{name:"script",type:"S",binding:"P",property:"assembleScript"}];return(p,h)=>{const l=b,a=g,o=P,i=w,c=A,d=N,u=F;return f(),v(u,{name:"assembleFrontend","depending-task-names":["installFrontend"],inputs:r,"custom-environment-variables-supported":""},{title:t(()=>[e("Assemble frontend artifacts")]),skipConditions:t(()=>[n(l,{name:"packageJsonDirectory"}),n(a,null,{default:t(()=>[e("/package.json")]),_:1}),e(" file does not exist, or "),n(l,{name:"assembleScript"}),e(" is "),n(a,null,{default:t(()=>[e("null")]),_:1}),e(". ")]),description:t(()=>[e(" This task allows to execute a build script as part of a Gradle build. The build script shall be defined in the "),n(a,null,{default:t(()=>[e("package.json")]),_:1}),e(" file, and the "),n(l,{name:"assembleScript"}),e(" property shall be set with the corresponding "),n(a,null,{default:t(()=>[e("npm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("pnpm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("yarn")]),_:1}),e(" command. Apart from direct execution, the task is also executed when the Gradle lifecycle "),n(o,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:t(()=>[e("assemble")]),_:1}),e(" task is executed. "),s("div",we,[s("div",De,[s("h5",Pe,[e(" About "),n(o,{path:"/current/userguide/incremental_build.html"},{default:t(()=>[e("incremental build")]),_:1}),e(" and up-to-date checks ")]),s("p",Ce,[e(" If you execute this task several times in a row, you may notice the "),n(a,null,{default:t(()=>[e("npm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("pnpm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("yarn")]),_:1}),e(" command is always executed: Gradle does not skip the task based on a previous execution with the "),n(i,{outcome:"SUCCESS"}),e(" outcome. This is the expected behaviour because the task does not declare any input/output Gradle could track, to know the task is already "),n(i,{outcome:"UP-TO-DATE"}),e(" (e.g. unlike task "),n(c,{name:"installNode"}),e("). The task provides the ability to plug the developer's own Javascript build process to Gradle, and nothing more. Every Javascript build process is unique: it depends on the project, the languages involved (e.g. TypeScript, JSX, ECMA script, SASS, SCSS...), the directory layout, the build utilities (Webpack...), etc., chosen by the team. Moreover, some build utilities are already able to build artifacts incrementally. The plugin does not duplicate this logic. If you are about to tweak this task, take a look at these "),n(d,{path:`${p.$config.public.paths.tasks}#builtin-tasks-customization`},{default:t(()=>[e("recommendations")]),_:1},8,["path"]),e(". ")])])])]),_:1})}}}),Ie=k({__name:"check-frontend-task",setup(y){const r=[{name:"packageJsonDirectory",type:"F",binding:"P",property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"},{name:"script",type:"S",binding:"P",property:"checkScript"}];return(p,h)=>{const l=b,a=g,o=P,i=F;return f(),v(i,{name:"checkFrontend","depending-task-names":["installFrontend"],inputs:r,"custom-environment-variables-supported":""},{title:t(()=>[e("Check frontend application")]),skipConditions:t(()=>[n(l,{name:"packageJsonDirectory"}),n(a,null,{default:t(()=>[e("/package.json")]),_:1}),e(" file does not exist, or "),n(l,{name:"checkScript"}),e(" is "),n(a,null,{default:t(()=>[e("null")]),_:1}),e(". ")]),description:t(()=>[s("p",null,[e(" This task may be used to integrate a check script into a Gradle build. The check script shall be defined in the "),n(a,null,{default:t(()=>[e("package.json")]),_:1}),e(" file, and the "),n(l,{name:"checkScript"}),e(" property shall be set with the corresponding "),n(a,null,{default:t(()=>[e("npm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("pnpm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("yarn")]),_:1}),e(" command. A typical check script may lint source files, execute tests, and/or perform additional analysis actions. Apart from direct execution, the task is also executed when the Gradle lifecycle "),n(o,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:t(()=>[e("check")]),_:1}),e(" task is executed. ")])]),_:1})}}}),Ge=k({__name:"publish-frontend-task",setup(y){const r=[{name:"packageJsonDirectory",type:"F",binding:"P",property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:"F",binding:"P",property:"nodeInstallDirectory"},{name:"script",type:"S",binding:"P",property:"publishScript"}];return(p,h)=>{const l=b,a=g,o=F;return f(),v(o,{name:"publishFrontend","depending-task-names":["assembleFrontend"],inputs:r,"custom-environment-variables-supported":""},{title:t(()=>[e("Publish frontend artifacts")]),skipConditions:t(()=>[n(l,{name:"packageJsonDirectory"}),n(a,null,{default:t(()=>[e("/package.json")]),_:1}),e(" file does not exist, or "),n(l,{name:"assembleScript"}),e(" is "),n(a,null,{default:t(()=>[e("null")]),_:1}),e(", or "),n(l,{name:"publishScript"}),e(" is "),n(a,null,{default:t(()=>[e("null")]),_:1}),e(". ")]),description:t(()=>[s("p",null,[e(" This task may be used to integrate a publish script into a Gradle build. The publish script shall be defined in the "),n(a,null,{default:t(()=>[e("package.json")]),_:1}),e(" file, and the "),n(l,{name:"publishScript"}),e(" property shall be set with the corresponding "),n(a,null,{default:t(()=>[e("npm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("pnpm")]),_:1}),e("/"),n(a,null,{default:t(()=>[e("yarn")]),_:1}),e(" command. Apart from direct execution, the task is also executed when the Gradle "),n(a,null,{default:t(()=>[e("publish")]),_:1}),e(" task is executed. ")])]),_:1})}}}),Ae=s("p",null,"The plugin registers multiple tasks, that may have dependencies with each other, and also with:",-1),je={class:"text-center"},Le=s("p",null,"Example hereafter shows how to customize the environment for a given task:",-1),O="https://siouan.github.io/frontend-gradle-plugin/node-corepack-npm-pnpm-yarn-tasks",R="Gradle tasks to run node, corepack, npm, pnpm, yarn commands",M="Gradle tasks and types provided by the plugin to run node/corepack/npm/pnpm/yarn: integration, dependencies, customization, recommendations",tn=k({__name:"node-corepack-npm-pnpm-yarn-tasks",setup(y){return me({link:[{rel:"canonical",href:O}]}),X({description:M,ogDescription:M,ogTitle:R,ogUrl:O,title:R}),(r,p)=>{const h=H,l=P,a=g,o=Z,i=W,c=se,d=_e,u=he,_=ge,x=ke,D=Te,C=xe,j=Se,L=Ie,U=Ge,Y=Q,z=ee,V=ne,q=te,B=ae,E=N,m=A,$=de,T=ue;return f(),le("section",null,[n(h,null,{default:t(()=>[e("Tasks")]),_:1}),Ae,s("ul",null,[s("li",null,[e(" Gradle lifecycle tasks defined in the "),n(l,{path:"/current/userguide/base_plugin.html"},{default:t(()=>[e("Gradle Base plugin")]),_:1}),e(": "),n(a,null,{default:t(()=>[e("clean")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("assemble")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("check")]),_:1}),e(". ")]),s("li",null,[e(" Tasks defined in the Gradle Publishing plugin: "),n(a,null,{default:t(()=>[e("publish")]),_:1}),e(". ")])]),n(o,null,{default:t(()=>[e("Dependency tree")]),_:1}),s("p",je,[n(i,{class:"w-100"})]),n(o,null,{default:t(()=>[e("Reference")]),_:1}),s("section",null,[n(c,null,{default:t(()=>[e("Built-in tasks")]),_:1}),n(d),n(u),n(_),n(x),n(D),n(C),n(j),n(L),n(U)]),s("section",null,[n(c,null,{default:t(()=>[e("Additional types")]),_:1}),n(Y),n(z),n(V),n(q),n(B)]),s("section",null,[n(c,{id:"custom-environment-variables"},{default:t(()=>[e(" Environment variables in "),n(a,null,{default:t(()=>[e("node")]),_:1}),e("-based tasks "),n(E,{path:`${r.$config.public.paths.tasks}#app`,class:"small text-info"},{default:t(()=>[e("â")]),_:1},8,["path"])]),_:1}),s("p",null,[e(" The plugin provides multiple tasks or types that execute under-the-hood a "),n(a,null,{default:t(()=>[e("node")]),_:1}),e("-based command: "),n(m,{name:"installCorepack"}),e(", "),n(m,{name:"installPackageManager"}),e(", "),n(m,{name:"installFrontend"}),e(", "),n(m,{name:"cleanFrontend"}),e(", "),n(m,{name:"assembleFrontend"}),e(", "),n(m,{name:"checkFrontend"}),e(", "),n(m,{name:"publishFrontend"}),e(", "),n(m,{name:"RunNode"}),e(", "),n(m,{name:"RunCorepack"}),e(", "),n(m,{name:"RunNpm"}),e(", "),n(m,{name:"RunPnpm"}),e(", "),n(m,{name:"RunYarn"}),e(". These tasks forward environment variables visible by the Gradle process to "),n(a,null,{default:t(()=>[e("node")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("corepack")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("npm")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("pnpm")]),_:1}),e(", "),n(a,null,{default:t(()=>[e("yarn")]),_:1}),e(" commands. These variables may be overwritten and/or new variables may be added to the environment forwarded to the command. If you need to alter the "),n(a,null,{default:t(()=>[e("PATH")]),_:1}),e(" environment variable, and though this is generally a rare situation, keep in mind the plugin adds its own paths so as the relevant "),n(a,null,{default:t(()=>[e("node")]),_:1}),e(" executable can be found. ")]),Le,n($,null,{groovy:t(()=>[s("pre",null,[n(a,null,{default:t(()=>[e(`
import org.siouan.frontendgradleplugin.infrastructure.gradle.AssembleTask
tasks.named('assembleFrontend', AssembleTask) {
    environmentVariables.put('NODE_OPTIONS', '--max_old_space_size=50 --title="Assembling frontend"')
}`)]),_:1})])]),kotlin:t(()=>[s("pre",null,[n(a,null,{default:t(()=>[e(`
import org.siouan.frontendgradleplugin.infrastructure.gradle.AssembleTask
tasks.named<AssembleTask>("assembleFrontend") {
    environmentVariables.put("NODE_OPTIONS", "--max_old_space_size=50 --title=\\"Assembling frontend\\"")
}`)]),_:1})])]),_:1}),s("p",null,[e(" Example hereafter shows how to apply an environment variable to all tasks running a "),n(a,null,{default:t(()=>[e("node")]),_:1}),e("-based command: ")]),n($,null,{groovy:t(()=>[s("pre",null,[n(a,null,{default:t(()=>[e(`
import org.siouan.frontendgradleplugin.infrastructure.gradle.AbstractRunCommandTask
tasks.withType(AbstractRunCommandTask) {
    environmentVariables.put('NODE_DEBUG', 'module')
}`)]),_:1})])]),kotlin:t(()=>[s("pre",null,[n(a,null,{default:t(()=>[e(`
import org.siouan.frontendgradleplugin.infrastructure.gradle.AbstractRunCommandTask
tasks.withType<AbstractRunCommandTask> {
    environmentVariables.put("NODE_DEBUG", "module")
}`)]),_:1})])]),_:1}),n(c,{id:"builtin-tasks-customization"},{default:t(()=>[e(" Built-in tasks customization "),n(E,{path:`${r.$config.public.paths.tasks}#app`,class:"small text-info"},{default:t(()=>[e("â")]),_:1},8,["path"])]),_:1}),s("p",null,[e(" If you need to customize the plugin's built-in tasks (e.g. declare additional I/O or dependencies), it is important to conform to the "),n(l,{path:"/current/userguide/task_configuration_avoidance.html#sec:old_vs_new_configuration_api_overview"},{default:t(()=>[e("Configuration avoidance API")]),_:1}),e(": use references of task providers instead of references of tasks, and continue taking advantage of the lazy configuration strategy the plugin already implements. The examples below introduce the implementation expected with simple cases: ")]),n($,null,{groovy:t(()=>[s("pre",null,[n(a,null,{default:t(()=>[n(T,null,{default:t(()=>[e(`// Configuring a predefined task.
// LEGACY SYNTAX: task 'installFrontend' is immediately created and configured, as well as task
// 'otherTask', even if both tasks are not executed.`)]),_:1}),e(`
installFrontend {
    dependsOn 'otherTask'
    inputs.files('package.json', 'package-lock.json')
}
`),n(T,null,{default:t(()=>[e(`// MODERN SYNTAX: task 'installFrontend' is created and configured only when Gradle is about to execute it.
// Consequently, task 'otherTask' is also created and configured later. Let's also reinforce this behaviour
// by using its provider to retrieve the task.`)]),_:1}),e(`
tasks.named('installFrontend') {
    dependsOn tasks.named('otherTask')
    inputs.files('package.json', 'package-lock.json')
}

`),n(T,null,{default:t(()=>[e(`// Defining a new task
// LEGACY SYNTAX: task 'eagerTask' is immediately created and configured, as well as task
// 'installFrontend', even if both tasks are not executed.`)]),_:1}),e(`
task eagerTask {
    dependsOn 'installFrontend'
}
`),n(T,null,{default:t(()=>[e(`// MODERN SYNTAX: task 'lazyTask' is created and configured only when Gradle is about to execute it.
// Consequently, task 'installFrontend' is also created and configured later. Let's also reinforce this
// behaviour by using its provider to retrieve the task.`)]),_:1}),e(`
tasks.register('lazyTask') {
    dependsOn tasks.named('installFrontend')
}`)]),_:1})])]),kotlin:t(()=>[s("pre",null,[n(a,null,{default:t(()=>[n(T,null,{default:t(()=>[e(`// Configuring a predefined task.
// LEGACY SYNTAX: task 'installFrontend' is immediately created and configured, as well as task
// 'otherTask', even if both tasks are not executed.`)]),_:1}),e(`
installFrontend {
    dependsOn("otherTask")
    inputs.files("package.json", "package-lock.json")
}
`),n(T,null,{default:t(()=>[e(`// MODERN SYNTAX: task 'installFrontend' is created and configured only when Gradle is about to execute it.
// Consequently, task 'otherTask' is also created and configured later.`)]),_:1}),e(`
tasks.named<InstallFrontendTask>("installFrontend") {
    dependsOn(tasks.named("otherTask"))
    inputs.files("package.json", "package-lock.json")
}

`),n(T,null,{default:t(()=>[e(`// Defining a new task
// LEGACY SYNTAX: task 'eagerTask' is immediately created and configured, as well as task
// 'installFrontend', even if both tasks are not executed.`)]),_:1}),e(`
task eagerTask {
    dependsOn("installFrontend")
}
`),n(T,null,{default:t(()=>[e(`// MODERN SYNTAX: task 'lazyTask' is created and configured only when Gradle is about to execute it.
// Consequently, task 'installFrontend' is also created and configured later. Let's also reinforce this
// behaviour by using its provider to retrieve the task.`)]),_:1}),e(`
tasks.register("lazyTask") {
    dependsOn(tasks.named("installFrontend"))
}`)]),_:1})])]),_:1}),s("p",null,[e(" If your application uses the legacy syntax, you may find further instructions to migrate to the modern syntax in this Gradle "),n(l,{path:"/current/userguide/task_configuration_avoidance.html#sec:task_configuration_avoidance_migration_guidelines"},{default:t(()=>[e("guide")]),_:1}),e(". ")])])])}}});export{tn as default};
